## Авторизация и управление пользователям
Пока управление полномочиями пользователя задаются четез примитивный механизм: при переходе в режим редактирования, указывается код пользователя user. Коды пользователя нигде в вебовском простанстве не "выложены", это немного ограничивает возможность повреждения данных через неумелые действия. 

## Создание новой кассеты

## Загрузка файлов и групп файлов

Основой загрузки является форма передачи нескольких файлов от клиета к серверу. Пользователь запускает страницу с формой, по нажатию кнопки выбирает файлы на своей клиентской машине и отсылает их серверу. Там "посылочка" приходит и разбирается по файлам. Эта страница FileUpload1, ее внешнее название "/file-upload-1"

В пришедшей посылке файлы содержат следующую информацию: 
file.Name - имя файла
file.LastModified - дата последней модификации файла
file.ContentType - тип контента файла
file.Size - размер файла

А еще есть доступ к стриму файла
file.OpenReadStream(...)

В итоге, у нас есть некоторая метаинформация и есть сам файл. Файл сервер может записать куда надо, мета информация может использоваться в базе данных. 

Для фиксации документа нужно:
1) иметь активную кассету acassette
2) иметь активный fog-документ, желательно метаинформационный активной кассеты
3) В активной кассете иметь "карточку" класса http://fogid.net/o/cassette с идентификатором cass_id 
4) В активной кассете вычислить следующую позицию для докумнета, а с ней - uri.
5) Файл документа поместить в оригиналы по имеющемуся uri
6) Вычислить разные копии для интернета
7) взять некоторый новый идентификатор из области идентификаторов активной кассеты
8) В зависимости от типа контента документа породить либо document, либо photo-doc, либо video-doc, либо audio-doc с вычисленными name, uri, doc-content
9) Этот документ прикрепить к кассете, через "элемент коллекции"

Вот сколько действи надо сделать... Причем метаинформация будет пополняться через специальные стредства типа EXIF. А копии будут делаться с помощью возможно больших программ типа ffmpeg. 


### 20220201 14:37
Я очень сильно задумался над авторизацией и припиской пользователя к владению. Похоже, надо корректировать схему. С авторизацией пусть будет все как обычно. Но есть две приписки, которые существенны для процесса изменения данных. Это активная кассета и активный фог. Активная кассета может быть только у информационного администратора. Активный фог - у оператора. То есть, кроме ничего не изменяющего "читателя", могут быть указанные роли. Сейчас это приписка осуществляется автоматически, если находится подходящая критерию кассета или подходящий критерию фог. 

Информационный администратор может создавать кассету

### 20220202 11:35

Схема формирования словаря dicsInversePropsForType. Этот словарь устанавливает соответствие между именами классов и массивами имен свойств, таких, что они могут "прикрепляться" к объектам класса как "сток", т.е. через range определения.

Из всех онтологических определений возмем определения объектных свойств ObjectProperty. Из них выделим единым массивом (потоком) свойства с именем range. Каждое свойство преобразуем в пару {имя свойства, имя range класса}. Сгруппируем по второму элементу, т.е. по именам range-классов, преобразуем в искомое соответствие (словарь). Где здесь наследование свойств? Там, где появляется класс. Имя range класса надо превратить в множество потомков. Далее, все будет нормально. Попробую.

### 20220203 14:14
Вроде исправил ошибки и программа заработала. Минимальный вариант следующий: все файлы грузятся как документы (document) с какими-то contenttype. Соответственно, доступ к документу производится штатными средствами HTTP, т.е. получением документа с этим типом контента. Как правило, это будет приводить к копированию (download) файла на компьютер пользователя. Зато все можно будет посмотреть "в оригинале". 

Еще я раздумываю как ввод файлов согласовать с действиями по редактированию. В дальнейшем, документы можно преобразовать в photo-doc и др. Можно будет подготовить превьюшки и создать обычный режим визуального представления документов. 

Так как все-таки загружать файлы "зряче", сохраняя контекст действий. Как мне кажется, нужно добавлять файлы в том окне, в котором есть набор уже загруженных файлов, к которым идет добавление. Это либо кассета, либо коллекция. С кассетой все довольно логично и наверное нужно иметь такой режим. Однако, файлов может накопиться довольно много и это будет препятствовать восприятию контекста. Если к некольки тысячам иеющихся файлов будет добавлен еще один, это не будет заметно. Но файлы можно добавлять в несколько коллекций, включая саму кассету. 

Контекст ввода может быть и через другие отношения. Например, отражение или авторство. Либо это может быть документ, состоящий из частей, напр. сканов. Контекст работы с документами представляет собой множество документов, которые визуально хотелось бы контролировать на предмет расположения в нем элементов. Когда мы добавляем несколько файлов, хотелось бы более менее сохранять предыдущую картинку и компактно видеть появившиеся документы. Это, в частности означает, что нужны режимы сортировки, согласованные с режимами сортировки элементов, при забирании процессом upload. 

### 20220205 09:29
За предыдущие пару дней не сделал ничего полезного... Надо все же поработать. Делать красивый дизайн можно, но не имеет большого смысла. Большой смысл имеет вычисление превьюшек.Кстати, я подумал вот что: contenttype это для какого документа. Пхоже, для оригинала. А вот превьюшки могут иметь свои типы контента. Надо буде проверить, что это выполняется. 

Итак, превьющки. Нужен список файлов. Его можно вычислить по отсутствующим превьюшкам, можно формировать при загрузке. Теоретически можно не вычислять заранее превьюшки, а вычислять их по мере необходмости. Для фотографий, особенно в формате jpeg, это выглядит интересным. Но для видео - сомнительным. 

Итак, веду создание превьюшек в порядке обработки приходящих файлов. Пока последовательно, но хорошо бы - асинхронно. 

### 20220207 07:30
Мои поиски приемлемого способа подготовки превьюшек выявили неплохую систему vips (https://www.libvips.org). Это для работы с растровыми изображениями. Причем все работает для разных ОС, в режиме библиотеки или в виде desktop-приложения. Я загрузил и испытал desktop. Выявил оновной запуск, который мне понадобится:
```
D:\Home\bin\vips-dev-8.12\bin\vips.exe resize map.jpg out.jpg 0,078125
``` 
По отзывам, работает быстро и с малым расходом ОЗУ. Попробую использовать. Попробую сейчас преобразовать страницу FileUpload1 в DocsUpload. Эта страница будет загружать файлы, изучать их метаинфорацию, а на базе полученной информации строить объекты и формировать командный файл для вычисления превьюшек.

Чтобы было надежнее, сделаю преобразования в три этапа. Первый - прием файлов и формирование имеющейся информации о файлах. На втором этапе - ...

### 20220210 09:47
Наконец, создание превьюшек сделано. Надо теперь довести эти дела до ума и думать о том, что делать дальше. Что такое "довести до ума"? 

1) Собрать и зафиксировать нужное количество метаинформационных полей. Кажется, речь идет о дате съемки или создания. 
2) Нужно организовать загрузку файлов и встроить загрузку в контекст работы с портретом. 
3) Забыл уже, потом вспомню... 

Работаю!

Первый пункт реализовал. Возможно, надо делать более комплексно, но пока учет EXIF в части даты съемки уже кое-что. 

Теперь по поводу второго пункта. Нам надо восстанавливать контекст после загрузки. Будет естественным, выдавать портрет коллекции активной кассеты. Рассмотрим комплекс проблем в комплексе... 

В верхнем (правом) меню должны быть следующие переключатели: имя пользователя, имя кассеты, кнопка загрузки документов и кнопка фиксации. Переход к другому пользователю контролируется. Если пользователь задан, то у него должна быть либо кассета, либо фог-документ. Попробую перекомпоновать. 

### 20220211 06:43
Есть пара "загвоздок". Первая - иногда студия чего-то не понимает в .razor компоненте и неправильно расцвечивает. Вторая - libvips в базовом комплекте не признает .BMP файлы. В интернете https://github.com/libvips/libvips/issues/1528 написано, что нужен Magic API или ImageMagic

Удалось сделать почти все, что задумал в загрузке. Кстати, я понял почему "иногда студия не понямиет...". Это когда компонет переименовывается. 
Теперь сделаю переход на конкретную страницу после загрузки. 



