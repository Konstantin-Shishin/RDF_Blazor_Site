Это скорее не "идеи", а дневник разработки. В данном случае, разработки R-решений

### 20220405 08:54
Вчера закончил доведение движка данных OAData и адаптера к нему OmAdapter. Последнюю ошибку искал и исправлял уже ночью. Теперь займусь 
другой частью работы с данными - онтологией. Надо породить R-решение для перечислимы типов. Перечислимые у меня в расширенном OWL описываются
так:
```
  <EnumerationType rdf:about="http://fogid.net/o/person-sex">
    <state value="m" xml:lang="ru">муж.</state>
    <state value="f" xml:lang="ru">жен.</state>
    <state value="m" xml:lang="en">male</state>
    <state value="f" xml:lang="en">female</state>
  </EnumerationType>
```
Это похоже на каноническую форму RDF-записи, но это не запись. Мешает только "value". Посмотрел как перечисление определяется в OWL - брр...
такого не хочется. 

Пока видится два варианта сведения "моего" перечисления к каноническим формам: либо объявить предикатом это самое value, либо объявить 
еще одну форму свойства. Первая идея делает формализм не стабильным относительно конкретной спецификации. Хочется, чтобы набор предикатов был
фиксированным (и не большим). Вторая идея выглядит не такой уж глупой, особенно если тема предиката не будет переменной свойства. Ну например,
в виде триплетов:
```
// Стандартная запись
<#spiderman>
    rel:enemyOf <#green-goblin> ;
    a foaf:Person ;
    foaf:name "Spiderman", "Человек-паук"@ru .
// Моя запись
<http://fogid.net/o/person-sex> 
    a <EnumerationType> ;
    <rdfs:label> "пол человека"@ru ;
    <rdfs:label> "person sex"@en ;
    "m" "муж."@ru ;
    "f" "жен."@ru ;
    "m" "male"@en ;
    "f" "female"@en .
```
Вроде даже симпатично! Надеюсь, это ничему не противоречит. Теперь если в позиции range будет конструкция класса <EnumerationType>, то
мы значем что делать. Но чем это отличается от DatatypeProperty? Приведу пример:
```
  <DatatypeProperty rdf:about="http://fogid.net/o/description" priority="s">
    <label xml:lang="ru">описание</label>
    <label xml:lang="en">description</label>
    <domain rdf:resource="http://fogid.net/o/sys-obj"/>
    <range rdf:resource="http://fogid.net/o/text" style="textarea"/>
  </DatatypeProperty>
```
label есть, описание свойств есть. Главное - label. Что может означать StateProperty в общем случае? То есть в случае, когда элемент не 
класса EnumerationType. По виду, это набор каких-то пар key-value еще с языковыми вариантами для одного ключа. И это набор пар "привязан"
к какому-то онтологическому элементу. Напр. для класса, это что? Не знаю... Возможно и не нужна такая интерпретация. Пока не буду об этом
думать. 

Итак, подведу промежуточные итоги. Мы вводим новый вид RProperty, напр. RState, что-нибудь вроде:
```
    // Вариант 1
    public class RState : RProperty 
    {
        public string Key { get; set; }
        public string Value { get; set; }
        public string lang { get; set; }
    }
```
В этом определении есть недостаток, это свойство Prop, которое осталось "за кадром". Пока получалось, что оно не нужно. Да и какое-то значение
надо будет присвивать. Еще я обратил внимание на то, что языковый спецификатор по-прежнему отсутствует в RField. Кстати, как все работает
без спецификатора? На одну ошибку я уже наткнулся, искал довольно долго...

Посмотрел на места, в которых прямо используется RField. Их много. В большинстве, кажется, добавление последного поля не вызовет проблем. Это
потому, что значение или инициируется полями, отсутствие поля не приведет к проблеме. Либо поля берутся через индекс массива, начальные индексы
не меняются, проблем не возникает. Могут быть проблемы в сериализации, с этим я уже сталкивался...

С другой стороны, для каждого текста добавлять языковый спецификатор, выглядит не очень оправданным. Я об этом думал и не слишком преуспел в 
размышлениях. В большинстве случаев, когда есть идентификаторы, а не слова, спецификатор просто не нужен. Нужен в довольно редких случаях, когда 
надо из текстовых полей с одним идентификатором колонки, выбрать один вариант на основе языковой фильтрации. Именно множественность текстовых 
значений полей есть основание к языковому спецификатору. Языковый спецификатор можно делать по-разному. Например, в виде:
```
"Человек-паук@ru"
```
Такой способ ограничивает сами строчки, увы... Есть типичное место, где @ используется, это в email-адресах. 
А насколько "дорого" обходится введение языкового спецификатора в текстовые поля? Похоже, при сериализации, это минимально добавленный 1 байт.
То есть - пустая строка. 

Итак, за неимением лучшего, буду ориентироваться на вариант 1. Пока оставлю в стороне вопрос об отсутствии языкового поля в RField, видимо
к этому придется еще вернуться. 

Дополнительно к предыдущему, отмечу, что поле Key можно не использовать если использовать вышестоящее поле Prop. При этом, конструкция становится
соответствующей RField. Но то, что объявляется другой тип, решает проблему. Только если мы не захотим сделать Prop малого размера за счет небольшого
количества свойств. Все же - вариант 1. И пустая строка в позиции Prop. 

Итак, определяю класс RState и вношу его в трансляцию OWL-онтологии.  

Стоп!!! Есть довольно простой промежуточный вариант. Пока OWL/RDF/XML онтология остается в классе ROntology. Надо, как предложил Сергей, 
сделать методы работы с определениями перечислимых. Сначала сделаю на анализе XML-онтологии, потому можно будет подумать о замене. Итак, что нам
надо. Первое - определить, что для данного свойства, range входит в набор перечислимых. Далее - получить список пар ключ-значение, причем значение
надо искать из нужного языка. Ключи будут использоваться в комбо-боксах и фактически задавать текст для этого поля. Третье - по тексту поля,
т.е. значению ключа, надо вычислить и подставить в визуальную картину.

### 20220406 09:23
Дело движется. Написал и проверил уже 2 функции:
```
        public bool IsEnumeration(string prop) => enufildspecs.ContainsKey(prop);
        public string EnumValue(string prop, string val, string lang) // Корректно работает только с проверенными на IsEnumeration
```

Теперь надо написать еще. Для случая, когда значения нет, но надо редактировать. И для случая, когда значение есть и надо редактировать. 
А также модифицировать Update в случае перечислимых. Проблема (не сильная, конечно) заключается в том, что в двух нереализованных режимах 
функция должна возвращать группу значений. В случае текущего пустого результата, надо возвращать набор пар ключ-значение. Где ключ - это код, 
значение - читаемый текст.

Попробую передать массив массивов объектов. 

### 20220412 06:58
Сгодня - День космонавтики! 

Уже прошло почти 6 дней с последней записи в файле. Тогда я прекратил попытки исправить странную ошибку и передал наработанное
Сергею. Он им воспользовался, пошел несколько по другому пути: он не использовал bind, а обработал onChange элемента select.
Я об этом думал, но не придумал решения. Теперь пришлось взять решение у Сергея, эта часть программы теперь вроде зарботала. 

Теперь надо двигаться дальше. Но сначала, для разминки, испытаю полученное решение на "больших" данных. Полезу снова на fan,
по пути напишу письмецо Сергею. 

Решил, что несмого рано делать испытания. Хорошо бы:
- *сделать нормальную загрузку для trs
- Убрать все пустые варианты из записываемой после редактирования записи
- сделать видео-аудио-PDF

Ужас, снова вылезла та же наведенная (?) ошибка при поиске на похожую строку. Ошибку диагностирует компаратор, у которого 
первый аргумент - null. Что же происходит?

Похоже, я "напортачил" в TripleRecordStore. Причем ошибка - довольно тонкая. Возможно, она связана с общей логикой слабой 
динамики. В общем, trs хорошо работает там, где нет модификации данных и плохо - там, где она есть. Основная особенность 
выхода на ошибку: если редактируется какай-то запись, то Like-имена потом вызывают выход на офсет, по которому выборка объекта 
дает null. Напр. Изменяем Тестов, потом под запретом будут тесто, тест, тес, те, т. 

Это означает, что видимо повреждается векторынй индекс с именами. Оставлю эти проблемы на потом, сейчас сделаю правильную загрузку 
для om и испытаю на реальных данных.

