# Как делать кассеты

Кассета - специальный репозиторий, предназанченный для структурированного хранения мультимедиа файлов и обеспечения к ним доступа. И хотя файлы могут быть не только мультимедиа, а просто файлами, ориентация на мультимедиа проявляется в том, что для фото, видео и аудио файлов создаются условия, когда этот контент может доставляться потребителям в реальном времени и с меньшеми затратами на перемещение. Это делается с помощью специально подготовленных копий разного размера. Например, tiff фотография может "весить" 50 Мб, а ее копия, предназанченная для оперативного просмотра - 200 Кб. Совсем маленькие копии таких фотографий могут иметь объем в единицы килобайт. Это позволяет в реальном времени формировать в браузере композиции, состоящие из единичных фотографий достаточно большого размера и множества маленьких. 

Кассета характерна еще тем, что имеется также иерархическая структура размещения файлов в виде директорий, поддиректорий и файлов. Эта структура формируется в виде метаинформации - базы данных, выполненной в виде RDF-файла формата XML.

Кассета реализуется в виде иерархии директорий и файлов. У кассеты есть имя, оно совпадает с именем корневой директории. Имя кассеты довольно трудно изменить, это реально слабое место построения. Структура директории:
```
[имякассеты]
  cassette.finfo
  [originals]
    [0001]
      0001.ext
      0002.ext
      ...
    [0002]
      0001.ext
      0002.ext
      ...
  [documents]
    [small]
      [0001]
        0001.pre
        ...    
    [medium]
      [0001]     
    [normal]
      [0001]     
  [meta]
    имякассеты_current.fog
```
Квадратные скобки с текстом обозначают директорию и ее имя, без квадратных скобок - файлы. Таким образом, в кассете есть: оригиналы хранимых мультимедиа документов, их превью-копии размеров small, medium, normal и файл с метаинформацией в разделе meta. В корне есть файл, специфицирующий диреторию как касету.

Расширение .ext - расширение файла (.jpg, .mp4 и др.), расширение .pre - это расширение превью-файла (превьюшки), для действующей реализации для фото используется .jpg, для видео .mp4. Допустимо иметь несколько превьюшек этого размера для одного файла, напр. по некоторым причинам, для видео, воспроизводимого через Веб, нужно несколько форматов, напр. .mp4 и .webm. Главное условие, чтобы для одного файла в originals/DDDD все превьюшки должны   быть в соответствующих разделах documents/SIZE/DDDD с тем же DDDD. И должны иметь тот же номер-имя файла. Только расширитель может быть другой. 

Служебные имена файлов являются цифровыми, выровненными до 4 символов. Принципиальной логики в последовательности номеров не установлено. Также нет обязательности в использовании номеров в разных секциях DDDD. Сейчас это - повторение номеров с 0001 для каждой секции и последовательная нумерация, начиная с 1. Кажется, псевдоцифоровые имена файлов могут быть заменены на произвольные и если сделать небольшие изменения в коде, и 4 символа также не являются догмой. 

Фактически, сохранение документного файла в кассете означает следующее: файл получает новое имя в виде кода и помещается в очередную секцию. Количество файлов в секции не регламентировано и пока подразумевается в 1000. По идее, надо выяснить влияние количества файлов в директории на скорость доступа к файлам по имени и найти разумное количество. 

Информация о файле записывается в виде записи (элемента) в meta/имякассеты_current.fog. Также формируется (может формироваться) один или несколько элементов, связывающих этот элемент с информацией, имеющейся в этой кассете, возмжно и с внешней информацией. 

Кроме того, для некоторых видов мультимедиа документов (файлов), порождаются вспомогательные файлы, позволяющие визуализировать информацию, содержащующся в основном документе с меньшими затратами на перекачку, но с потерей качества. Увравляет параметрами создания превьюшек файл cassette.finfo, хотя параметры могут формироваться и как-то по-другому. 

В кассетах принят двойственный характер идентификации документов. Это отражает то, что документ это некоторая логическая сущность с атрибутами (напр. время создания) и связями с внешним миром (содержится в коллекции, имеет авторов и т.д.). И в то же время, документ важен как информационная единицаЮ т.е. своим контентом. Это как книга - есть библиографическая карточка, в которой издложены атрибуты и привзка к издательству, авторам и др., и есть сам том книги, который также надо где-то хранить и как-то выдавать. Логически, документ идентифицируется идентификатором - произвольной уникальной строкой символов и все логические ссылки на документ делаются с использованием идентификатора. А "физически", с документом, точнее его файлом сопоставляется некоторый код, у нас это код uri, который указывает в какой кассете и в каком месте находится оригинал. Небольшими преобразованиями кода, легко "добраться" и до его превью-файлов. 

### Структура метаинформационного файла *_current.fog

Этот файл, структуры RDF формата XML является основной базой данных кассеты. Используемый RDF является подмножеством стандартного RDF. Важным и ключевым отличием является то, что запись группирует все высказывания относительно общего субъекта, но может быть несколько записей с одним идентификатором. Истинным или оригиналом среди таках записей является та, у которой более поздняя временная отметка. 

Структура метаинформационного файла описывается некоторой онтологией. В настоящее время, это онтология ontology_iis-v13. В дальнейшем, онтология может быть расширена и даже заменена. 

Рассмотрим конкретную рекомендуемую структуру файла *_current.fog, где звездочка обозначает имя кассеты. 
```
<?xml version="1.0" encoding="utf-8"?>
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://fogid.net/o/" owner="mag_1" prefix="cass01_" counter="1001">
  <cassette rdf:about="id1">
    <name>cass01</name>
    <cassetteUri>iiss://cass01@iis.nsk.su/meta</cassetteUri>
  </cassette>
  <collection-member rdf:about="id2">
    <in-collection rdf:resource="cassetterootcollection" />
    <collection-item rdf:resource="id1" />
  </collection-member>
  <photo-doc rdf:about="id3">
    <name>GoldenBalk</name>
    <from-date>2021-04-28T18:55:17</from-date>
    <uri>iiss://cass01@iis.nsk.su/0001/0001/0001</uri>
    <documenttype>image/jpeg</documenttype>
  </photo-doc>
  <collection-member rdf:about="id4">
    <in-collection rdf:resource="id1" />
    <collection-item rdf:resource="id3" />
  </collection-member>
  ...
</rdf:RDF>
```
В заголовке корневого элемента rdf:RDF имеется обязательное для RDF определение пространства имен xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" и пространство имен, используемых без префикса xmlns="http://fogid.net/o/". Далее идет атрибут кассеты владелец owner="mag_1", обозначающий код того пользователя, которому позволено изменять состав и структуру кассеты и согласованно изменять метаинформационный файл. Есть еще два вспомогательных атрибута prefix и counter. Они предназначены для формирования уникальных идентификаторов. Очередной уникальный идентификатор формируется как конкатенация префикса и счетчика, после чего к значению счетчика добавляется единица.

В структуру кассеты внесены два рекомендуемых элемента: элемент cassette, являющийся логическим образом кассеты и следующий за ним элемент cassette-member, который указывает на то, что данная кассета является элементом внешней коллекции с идентификатором cassetterootcollection. Это сделано для того, чтобы кассеты, вносимые в базу данных можно было бы легко органнизовать в коллекцию всего лишь определив коллекцию с указанным идентификатором. 

В примере метаинформационного файла также есть два элемента, типичные для кассет, хранящих документный контент. Показана конструкция фотодокумента и включение этого определенного документа в кассету. В примере, для ясности понимания, использованы идентификаторы id1,... id4. На самом деле, могут использоваться и другие способы формирования глобальных идентификаторов, но сейчас рекомендуется их делать из префикса и каунтера, напр. вместо id1 мог бы быть cass01_1001, вместо id2 мог бы быть cass01_1002 и т.д. А счетчик в кассете был бы уже существенно измененным. 

Сейчас допустимо использовать любую систему формирования глобально уникальных идентификаторов, вплоть до Guid. Но в дальнейшем, предполагается сформировать распределенную систему хранения кассет и распределенную базу данных. Тогда нам очень понадобятся синтаксические свойства идентификаторов, фиксирующие в какой кассете может быть определение элемента. 

В примере не приведен еще один достаточно обычный способ структуризации информации, используемый для документных кассет. Это построение иерархии коллекций. В метаинформационном файле можно определить коллекцию и привязать через членство в коллекции к кассете или другой коллекции. И тогда документные элементы мы помещаем не в кассету, а в коллекцию. Это позволяет воспроизводить структуру директорий, которые состоят из директорий и файлов. Соотвественно, при вводе данных средствами drag-and-drop, можно корректно запрограммировать "бросание" в кассету или коллекцию кассеты целой директории.

### Документы и их атрибуты
Мы говорим про докумены в смысле мультимедиа документов, т.е. документов, которые можно сохранять и визуализировать. Более общее - использовать. Предполагается, что за документом лежит файл контента этого документа. Атрибутами документа являются его имя (name), дата создания (from-date) и некоторые другие. Особый смысл имеют два системных атрибута uri и documenttype. uri указывает место хранения документа, documenttype - его mime-тип. 

В текущей онтологии, документы могут быть 4-х классов: 
- document
- photo-doc
- video
- audio

Самый общий класс - просто документ, остальные конкретизируют мультимедиа суть файла. Общий специальные атрибут - uri. Его конструкция в настоящее время следующая:
```
iiss://имя_кассеты@iis.nsk.su/0001/DDDD/DDDD
``` 
Предполагается, что когда сменится протокол (iiss), изменится и конструкция. 

Квалификация документа documenttype должна соответствовать MIME коду для этого вида документов. Тип документа определяется по расширению файла. В настоящее время используется таблица:
```
        static public DocType[] docTypes = new[] {
            new DocType(".png", "image/png", ONames.TagPhotodoc),
            new DocType(".tif", "image/tiff", ONames.TagPhotodoc),
            new DocType(".jpg", "image/jpeg", ONames.TagPhotodoc),
            new DocType(".gif", "image/gif", ONames.TagPhotodoc),
            new DocType(".mp3", "audio/mpeg", ONames.TagAudio),
            new DocType(".wav", "audio/x-wav", ONames.TagAudio),
            new DocType(".mpg", "video/mpeg", ONames.TagVideo),
            new DocType(".mpeg", "video/mpeg", ONames.TagVideo),
            new DocType(".avi", "video/x-msvideo", ONames.TagVideo),
            new DocType(".swf", "video/swf", ONames.TagVideo),
            new DocType(".flv", "video/flv", ONames.TagVideo),
            new DocType(".wmv", "video/wmv", ONames.TagVideo),
            new DocType(".mp4", "video/mp4", ONames.TagVideo),
            new DocType(".mov", "video/mov", ONames.TagVideo),
            new DocType(".mts", "video/mts", ONames.TagVideo),
            new DocType(".txt", "application/text", ONames.TagDocument),
            new DocType(".doc", "application/msword", ONames.TagDocument),
            new DocType(".rtf", "application/rtf", ONames.TagDocument),
            new DocType(".pdf", "application/pdf", ONames.TagDocument),
            new DocType(".xls", "application/excel", ONames.TagDocument),
            new DocType(".xml", "application/xml", ONames.TagDocument),
            new DocType(".fog", "application/fog", ONames.TagDocument),
            new DocType(".htm", "application/html", ONames.TagDocument),
            new DocType(".html", "application/html", ONames.TagDocument),
        };
``` 
Сравнивая эту таблицу с более полным вариантом (https://en.wikipedia.org/wiki/Media_type), видно, что у нас нет текста (text/xml и др.), у нас нет JSON и т.д., так что есть над чем работать. Обратим внимание на .fog. Это наш формат для базы данных, т.е. RDF/XML по заданной онтологии. 

Как используется documenttype? При загрузке файла, по расширению определяется вариант типа документа и фиксируется в документной записи. При вычислении превьюшек, конкретные варианты типов документов предлагаются для вычисления и потом воспроизведения. Для фотодокументов превью-форматом является .jpeg, для видео - .mp4 и, может, .webm. Для аудио - .mp3. Также documenttype используется для вывода документов в разделе Content-type.

Возможен еще один специальный элемент для документов, сохраняющий в элементе документа метаинформацию, в текущей онтологии, используется элемент docmetainfo. В нем, в формате имя_мета: значение; (как в css), фиксируются пары имя-значение. Это могут быть размеры кадров, частота, EXIF и др. Сейчас это поле не используется. Метаинформация, в основном, сохраняется в файле оригинала, хотя доступ не ней может быть затруднен. 

### Получение информации о документе
Документ - это информация. Информация о документе - это информация об информации, т.е. метаинформация. Уже упоминалось, что для базы данных документов важны: имя файла, дата создания или последней модификации файла, разные мультимедиа параметры, напр. размер кадра. Эту инфорцию надо откуда-то взять. Часть этой информации как-то извлекается из документного файла. Этому способствуют некотрые стандартные способы сохрения метаинформации. В первую очередь, это касается стандарта EXIF. Существует возможность извлечения этой информации через имеющиеся в открытом доступе решения. К сожалению, такие характеристики как время съемки надежно извлекается только для электронных фотографий. Документы, образы которых получатся через сканирование или композиционную обработку, содержат не те времена, которые нужны. Кроме того, некоторые форматы вообще не поддерживают встроенную метаинформацию. 

Некоторой заменой части информации является метаинформация файла, которые посылается на хранение и обработку. К сожалению, имеющиеся у файла метаданные о датах редко сохраняется при разных перемещаениях или трансформациях. 

Довольно большая неопределенность существует в связи с видеоматериалом. Единого формата метаинфорамации в видеоформатах видимо нет, но какие-то есть. В этом плане, лучше полагаться на способы, предложенные и реализованные специалистами в обработке документов. 

### Полезные программы
Полезные программы были выявлены через оценку их применимости к обработке документов, оценке пользователей и специалистов, личный опыт применения. Все они свляются программами с открытым кодом, свободного распространения, работающие как в среде Windows, так и под Линуксом. 

Извлечение метаинформации можно осуществлять посредством MediaInfo.
Это приложение предназначено для получения из видео и аудио файлов метаинформации. Причем какую-то метаинформацию (размеры) оно получает и из имиджей. Приложение удобно еще и тем, что результат может быть не только текстовым, но и XML и JSON. Пример выдачи анализа программой MediaInfo:
```
<?xml version="1.0" encoding="UTF-8"?>
<Mediainfo version="0.7.35">
  <File>
    <track type="General">
      <Complete_name>F:\Altai\AltayDzhozator2007.wmv</Complete_name>
      <Format>Windows Media</Format>
      <File_size>653 MiB</File_size>
      <Duration>1h 1mn</Duration>
    </track>
    <track type="Video">
      <Duration>1h 1mn</Duration>
      <Bit_rate>1 356 Kbps</Bit_rate>
      <Width>720 pixels</Width>
      <Height>576 pixels</Height>
      <Display_aspect_ratio>5:4</Display_aspect_ratio>
      <Frame_rate>25.000 fps</Frame_rate>
    </track>
    <track type="Audio">
      <Sampling_rate>44.1 KHz</Sampling_rate>
      <Bit_depth>16 bits</Bit_depth>
      <Stream_size>56.1 MiB (9%)</Stream_size>
    </track>
  </File>
</Mediainfo>
``` 
Метаинформационные поля в выдаче достаточно очевидны и легко извлекаемы. Для последующих преображований существенными являются ширина и высота кадра или Display_spect_ratio, а для целей демонстрации существенными являются продолжительность и ширина/высота, для целей скачивания клиенту - размер файла и т.д.

ffmpeg - другая полезная программа, которая позволяет преобразовывать видео материалы. В базовом случае, указывается файл с видео достаточно широкого спектра форматов и параметры преобразования этого файла в другой. Программа умеет использовать разные кодеки, варьировать степень сжатиявидео и аудио, изменять размеры и частоту кадров и многое другое. Параметры можно проанализировать по документации, сейчас нам достаточно рассмотреть пример преобразования:
```
ffmpeg -i {0} -y -vcodec libx264 -b 4050K -ar 22050 -s 1440x1080 {1}.mp4
```
Здесь указан ввод в виде пути к файлу, помещаенного в нулевой параметр, libx264 это один из видео кодеков, указанный в качестве применения, параметр -b указывает видео bitrate, как параметр управления скоростью порождаемого видео потока, при меньших значениях, качество картинки уменьшается. Параметр -ar управляет аудио bitrate. Очень важным является параметр -s (size), устанавливающий размеры получаемого кадра. Последним идет имя файла куда направляется получаемый видеофайл. 

Особую роль играет параметр устанавливаемого размера. Этот размер должен быть согласован с размером исходного файла иначе будет искажение картинки. Как уже указывалось, размер кадра видеофайла можно получить применением специальных программ (мы используем MediaInfo). 

Аналогичные действия по изменению параметров производится для имиджей. Работа с фотографиями является довольно традиционной областью программирования. Можно закачивать фотографии в оперативную память, применять процедуры преобразования, сохранять в нужных форматах. Есть библиотеки по работе с EXIF метаинформацией, хотя EXIF не всегда применяется и применяется не для всех форматов. Подобный подход реализован в нашем приложении cmanager. Проблема прямого программирования преобразования имиджей заключается в том, что (кажется) нет единой библиотеки (для .NET) для Windows и Linux. 
 
Мои поиски приемлемого способа подготовки превьюшек выявили неплохую систему vips (https://www.libvips.org). Это для работы с растровыми изображениями. Причем все работает для разных ОС, в режиме библиотеки или в виде desktop-приложения. Я загрузил и испытал desktop. Выявил основной запуск, который мне понадобится:
```
D:\Home\bin\vips-dev-8.12\bin\vips.exe resize map.jpg out.jpg 0,078125
``` 
По отзывам, работает быстро и с малым расходом ОЗУ. Есть похоже и "загвоздки", напр libvips в базовом комплекте не признает .BMP файлы. В интернете https://github.com/libvips/libvips/issues/1528 написано, что нужен Magic API или ImageMagic. 