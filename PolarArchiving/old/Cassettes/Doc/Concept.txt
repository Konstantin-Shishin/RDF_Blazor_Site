Концепция кассет
 
Кассетой назовем специально организованный информационный блок, объединяющий фрагменты базы данных, наборы файлов-документов и предвычисленную информацию, позволяющую оптимизировать доступ к кассете.
Для чего нужны кассеты
Предположим, в базе данных описан некоторый документ. Это может быть и текстовый документ и фото-видео-аудио. База данных позволяет увязать документ с другими сущностями через установление отношений типа «авторство», «отражение» и др. Кроме этого, документ, как правило еще является носителем информации, представленной в виде байтов, битов конкретных информационных записей, внешних относительно базы данных. Как правило, это файл, поток байтов которого и есть содержимое документа. Например, для фото-документа, имеется файл формата TIFF или JPEG, представляющий собственно фотографию.
Таким образом, в базе данных должна присутствовать информация, устанавливающая связь между записью документа и файлом документа. Обычным способом установления такой связи является указание координаты публикации документа в Интернете, т.е. указание URL файла. В этом способе имеется ряд недостатков. Во-первых, документ слишком жестко фиксируется в пространстве, т.е. определен единственный файл-источник для данного документа. Эта схема недостаточно гибкая, особенно для случаев, когда документ является статическим, т.е. неизменяемым, и в таких ситуациях можно было бы использовать копию вместо оригинала.
Во-вторых, легко заметить, что координата файла документа может быть разной для разных агентов. Для внешнего мира, это, как правило – интернетовский адрес, для  редактирующего приложения файл располагается обычно в файловой системе, что дает другой вид его адреса.
В-третьих, кроме доступа к файлу документа, нам может понадобиться доступ к некоторой дополнительной информации, связанной с данным файлом, причем динамически вычислять эту информацию по значению файла, не всегда рационально и приходится вычислять ее предварительно и где-то хранить. Например, для фотодокументов желательно иметь еще предвычисленные имиджи разных размеров. Доступ к такой информации требует регламентации и, как будет показано далее, специальных структурных построений. Указав же координату файла документа, мы «автоматически» обеспечиваем лишь доступ к файлу документа, но не к дополнительной информации. 
Таким образом, для каждого документа, прописанного в базе данных, надо бы иметь еще структуру и набор полей, т.е. «маленькую» базу данных, обеспечивающую доступ к нему и к дополнительной информации. Такая структура может оказаться излишне громоздкой, если ее реализовывать на слишком мелком уровне. Выходом является породить структуру для групп элементов, т.е. объединить подмножество документов в то, что в данном разделе называется кассетой.
В качестве модели кассеты может рассматриваться что-то вроде DVD-диска, в котором присутствует ряд свойств, таких как: перемещаемость, наличие внутренней структуры, множественность хранимых файлов, наличие дополнительной информации.
Общая структура кассет
Вернемся к связи записи документа с файлом документа. Предлагается использовать для этого URI (Universal Resource Identifier []). Логически, информация, оформленная в едином URI представляет четверку: {протокол, имя кассеты, код документа, класс документа}. Протокол указывает использованный вариант структуризации, способ интерпретации имени кассеты и кода документа. Имя кассеты идентифицирует кассету, а код документа идентифицирует документ. Класс документа категорирует документ, что нужно для многих целей, в частности, для корректной интерпретации содержимого файла документа. 
В качестве примера, рассмотрим простой кассетный протокол simple. В этом протоколе, мы файлы документов упорядочиваем в дерево директорий (папок) в соответствии с обычным строением файловой системы. Тогда именем кассеты будет имя папки, а кодом документа  будет относительный путь (path) к файлу от корневой для кассеты папки.
Поскольку имя кассеты рассматривается в общем пространстве Интернета, нам понадобится еще пространство имен, в котором определено имя кассеты. В итоге, общая структура URI для идентификации документного файла строится в соответствии с рекомендациями WWW-консорциума:
protocol://cassette-name@domain/document-code.extension  
Здесь в качестве пространства имен используется домен, зарегистрированный пользователем.
Для простого кассетного протокола, URI документа может выглядеть следующим образом:
simple://demo-cassette@iis.nsk.su/dir1/sub-dir11/photo1.jpg
Интерпретация простого протокола, указанная выше, предполагает следующий способ нахождения координаты файла:
координатаКассеты(demo-cassette) /dir1/sub-dir11/photo1.jpg
Заметим, что координата одной и той же кассеты вычисляется динамически и может быть разной для разных агентов поскольку от разных агентов путь к файлу может быть разным.
Простой кассетный протокол может быть полезен для ряда случаев, но его структура слишком примитивна и не содержит мета и предвычисленной информации. Рассмотрим более общую структуру кассеты.
Сохраним простую директорную структуру хранения файлов, но добавим две дополнительных специальных директории meta и preview. В директорию meta будет помещаться метаинформация, соответствующая хранимому массиву файлов, а в preview – информация, являющаяся дополнительной, к хранимому массиву, как правило, предназначенная для быстрой визуализации при просмотре. Мы постулируем, что раздел preview может быть вычислен по протоколу и массиву файлов. В разделе meta собирается информация, являющаяся частью базы данных, предназначенная для загрузки в базу данных при формировании модели.
Детальное устройство информационных блоков, помещаемых в meta и preview, зависит от системы соглашений по каждому конкретному протоколу. Теме не менее, желательно сохранить общие свойства такой информации. Рассмотрим один из возможных подходов к размещению мета и дополнительной информации в кассете.
В раздел meta желательно поместить следующую информацию: имя протокола, имя кассеты, комплектация кассеты, имя корневой коллекции, идентификатор корневой коллекции. Эта информация является интерфейсной и не предназначена для прямого включения в формируемую моделью базу данных. Другой частью meta-раздела является RDF-документ базы данных, обычно включающей в себя описатели документов кассеты и формирующей иерархию вложения документов в коллекции, соответствующие иерархии директорий хранения документов.
Третья часть meta-раздела представляет собой определение контекста документов. Вообще говоря, контекст возможно связывать с директориями, по которым распределены документы. Логика в этом вопросе такова: документ помещается в директорию исходя из некоторой логики пользователя по группированию документов по некоторым критериям. Если эта логика предполагает наследование контекста от директорий к поддиректориям, то это наследование можно было бы напрямую использовать в формировании базы данных. Однако, желательно структуру рабочих (не meta, не preview) директорий не искажать дополнительной информацией, хотя, возможно, следует допустить обе возможности.
Раздел preview также может быть устроен специфическим образом, но общая конструкция этого раздела – хранилище производных от документных файлов и базы данных для ускорения порождения специальных (просмотровых или транспортируемых) вариантов некоторых видов документов, хранящихся в кассете.
Раздел preview также можно было бы назвать индексным (индексом).
Установление связи между зарегистрированным документом кассеты и просмотровыми вариантами возможно либо через (простую) вспомогательную базу данных или через систему соглашений, приводящих к возможности вычисления координаты просмотрового варианта по, например, URI исходного документа.
Последний вариант рассмотрим на примере. Пусть нам требуется для фотодокументов предварительно вычислить и поместить в preview «маленькие» копии этих фотографий. Можно поступить достаточно просто: по URI документа вычислить идентификатор, например, с помощью некоторой взаимно [необязательно!] однозначной функции, а по этому идентификатору помещать различные по размерам имиджи в раздел preview. Имена таких вспомогательных файлов вычисляются, например, по формуле:
ФункцияПреобразования(URI-документа) + “_” + спецификатор + “.jpg”
где спецификатор – какой-нибудь код, соответствующий размеру имиджа (“s”, “m” и т.д.).
Соответственно, когда, при использовании, потребуется найти координату вспомогательной копии, то снова по URI документа вычисляется имя копии и файл будет доступен при фиксации базы для preview кассеты.
Использование базы данных для установления соответствия между документом и дополнительной информацией дает большую гибкость. Во-первых, база данных сама может являться хранилищем дополнительной информации. Во-вторых, с помощью базы данных можно регулировать наличие или отсутствие такой информации, а значит, необходимость ее вычисления в динамике доступа. В этом случае мы можем организовать дополнительную информацию по принципу кеша и экономить в вычислениях, используя принцип выполнения вычислений по необходимости («on demand»). В-третьих, база данных может содержать информацию о текущем варианте дополнительной информации к документу, которая может быть неодинаковой. Например, если в качестве предварительно вычисляемой информации для (больших) фотодокументов являются их уменьшенные копии, то размеры этих копий могут быть разными, а требуемый в конкретный момент времени размер может быть динамически вычислен не по большому оригиналу, а по близкой по размеру копии. Могут быть и другие преимущества использования базы данных для хранения дополнительной информации, например для случаев, когда часть оригиналов изменяется и требуется где-то фиксировать эту ситуацию и синхронизировать дополнительную информацию с оригиналом.
Принципиальным вопросом является: является ли рассматриваемая служебная база данных составной частью общей базы данных или нет. Предположительно, ответом на данный вопрос является и «нет» и «да». «Нет» – потому что эта информация имеет вспомогательный характер, касающийся организации правильной и эффективной работы с документами кассетами. «Да» – потому, что элементы вспомогательной информации могут иметь смысл и значение для процессов обработки пользовательского уровня. Например, обычно не используемая информация о документе, такая как размер файла, дата последней модификации, размеры имиджа (для фотографий), способ кодирования и др., могут иметь важное значение для некоторых процессов поиска, доступа и обработки.
Распределение кассеты в пространстве
До сих пор предполагалась концентрированность всей информации в одном месте хранения в виде дерева файлов и директорий, имеющего единый корень. Однако, рассмотрим реальную ситуацию, связанную с архивом документов. Например, архив фотодокументов содержащий порядка 10 тыс. образов фотодокументов, может иметь следующие характеристики:
- количество фотодокументов – 10 тыс.
- база данных, сопряженная с фотодокументами – 20 Мб. RDF-документов
- объем маленьких (100x100) образов документов – 30 Мб. Jpeg-имиджей
- объем средних (~800 px) образов документов – 1 Гб. Jpeg-имиджей
- объем файлов-оригиналов фотодокументов – 100 Гб. Tiff-имиджей.
Видно, что сведенная воедино информация становится очень тяжеловесной и плохо перемещаемой. В то же время, по условиям работы цифрового архива, доступ к оригиналам фотографий может быть ограничен или выполняться очень редко. Доступ к маленьким образам документам может осуществляться достаточно регулярно при обзоре коллекций и отражаемых в документам сущностей, они могут использоваться в виде «иконок». А средние размеры имиджей используются при просмотре заинтересовавшей пользователя фотографии. Это производится для единичных документов и не так часто.
Таким образом, чем больше соответствующий информационный блок, тем реже он используется.
В этих условиях, нет большой целесообразности хранить весь набор, все сегменты данных в одном месте, а часто и желательно разнести эти сегменты по разным местам. Например, оригиналы фотодокументов желательно убрать из публичного доступа или хотя бы ограничить доступ к ним. Такая постановка диктует необходимость наличия механизма распределения сегментов кассеты по разным местам публикации или размещения.
Предлагаемая схема модификации устройства кассеты следующая. Минимальный вариант кассеты состоит из базовой директории, т.е. директории, на которую устанавливается база (координата) при ее включении в ту или иную модель и поддиректории meta, содержащей полный набор метаинформационных файлов. Другие разделы могут присутствовать в базовой директории или нет. В последнем случае, в метаинформации можно будет узнать координату директории, в которой находится соответствующее содержимое. Такая информация объединяется в запись определения кассеты, что-нибудь типа:
<cassette rdf:about=”идентификатор кассеты”>
	<cassette-base>URL</cassette-base>
	<cassette-content>URL</cassette-content>
    <cassette-preview>URL</cassette-preview>
</cassette>
 
Ключевой позицией является установление соответствия между кассетой или ее секцией и URL-координатой, по которой эта кассета (секция) расположена. Попробуем воплотить это соответствие в информационную запись:
<cassette-locator rdf:about=””>
	<cassette-name>Имя кассеты</cassette-name>
	<section>иерархическое имя секции</section>
	<cs-placement>Относительный или абсолютный URL</cs-placement>
</cassette-locator>
 
Предполагается, что привязка кассеты или секции кассеты к конкретному месту расположения определено в самой кассете. Но это привязка может измениться конфигуратором модели, в котором могут быть заданы другие значения расположений, которые логически замещают для модели заданные в кассете дефолтные значения. Таким образом, общая рекомендация для задания соответствий следующая: в кассете указываются универсальные, не зависящие от расположения агента модели координаты, а в конфигураторе модели – оптимизированные пути доступа и более близкие копии, используемые вместо оригинала.
Задание контекстов для данных, размещенных в кассетах
 
 
URI документов
Рассмотрим набор функций, связывающих URI документов с необходимыми для обработки другими кодами. Пусть URI документа представляется в виде тройки:
uri = {protocol, cassette-name, file-code, extension}
Тогда рассмотрим следующие отображения
File-coord = GetCoord(uri, …)
File-coord = CoordComposition(protocol, CassetteLocation(cassette-name), file-code, extension)
Абстрактный интерфейс по работе с кассетами
Интерфейс модели
Основные структуры данных:
CassetteName – строка, означающее имя кассеты
DocumentUri – строка, означающая URI документа
 
public static CassetteName GetCassetteName(DocumentUri) – нахождение имени кассеты по URI документа
 
ModelConfiguration – класс, конфигурирующий модель, задает множество соответствий между кассетами и секциями и их URL
   
Cassette – класс кассет
   Методы и свойства;
  	CassetteName CName { get; } – имя кассеты
 
 
 
Регистрация кассет
Пусть созданием кассет занимается отдельная программа (SunTzu). Кассеты, формируемые на одном компьютере, еще можно локализовать, но для использования механизма кассет в распределенной ситуации, необходимы дополнительные средства, обеспечивающие регистрацию и перемещение кассет.
Для работы системы, нужно иметь рабочую область, где формируются и поддерживаются кассеты, регистратор кассет и области памяти, где кассеты могут располагаться.
Что такое регистратор кассет
 Логично, кассеты регистрировать в той же базе данных, что и вся наша распределенная RDF-среда. Пусть имеется RDF-документ, выполняющий роль регистратора кассет. Рассмотрим устройство базы данных кассет.  Единичной записью будет описание одной кассеты:
<cassette rdf:about="cs9822">
	<name>Тестовая кассета 001</name>
	<cassetteUri>iiss://TC001@iis.nsk.su</cassetteUri>
	<cassetteLocation>[HDD:mag_1]C:\home\iiss\TC001</cassetteLocation>
</cassette>  
Имеющаяся запись определяет кассету как совокупность имени, системного имени (URI) и расположения кассеты на диске или в Интернете. Теперь рассмотрим базовое действие, связанное с документами – доступ к контенту. В документной записи имеется URI документа вида:
[протокол] : // [имя кассеты] @ [домен] / [код документа]
Если мы работаем по протоколу iiss, то при наличии в реестре записей приведенного вида, алгоритм определения местоположения документа следующий:
По (расширенному) имени кассеты, в реестре ищется запись в которой определена данная кассета.
Из записи о кассете, извлекается расположение кассеты и формируется адрес доступа.
Из метаинформации о кассете находится определение документа, а в нем – системные поля доступа к нему и его временным образам. 
 
Далее, надо определить что такое секции. Секция кассеты – это регламентированная часть набора ее файлов. Секции могут располагаться в разных местах. Более того, секции могут располагаться в нескольких местах одновременно. Запись информации о секции выполним в следующем виде:
<cassetteSection rdf:about=””>
    <forCassette rdf:resource=”cs9822”/>
    <sectionType>original | meta | preview</sectionType>
    <sectionLocation>URL</sectionLocation>
</cassetteSection>
Причем preview может иметь моды, допустимые тем или иным протоколом. Например, preview.small, preview.normal.
Еще один момент, связанный с кассетами. Кассету можно рассматривать как том (volume), соответственно, коллекции – задают некоторую структуру размещения информации.  Желательно указать одну или несколько коллекций, которые напрямую связываются с томом, т.е. кассетой. Видимо, надо указать «членство» в кассете, что-то вроде:
<cassetteMember rdf:about=””>
    <inCassette rdf:resource=”cs9822”/>
    <rootMember rdf:resource=”id-of-collection”/>
</cassetteMember>
 
Загрузка кассет и модели
Введем понятие «загрузка кассеты в модель». Загрузка кассеты означает, что метаинформация – RDF-документы, расположенные в разделе meta, подгружаются в модель. В наборе файлов кассеты могут оказаться и RDF-документы, предназначенные для загрузки. Соответственно, второе действие, осуществляемое при загрузке кассеты – загрузка таких RDF-документов. Возможно, такую загрузку надо осуществлять более выборочно, но пока будем считать, что процесс загрузки внутренних для кассеты RDF-документов – автоматический.
Некоторая тонкость заключается в том, что модель не может работать базой данных пока она загружается. Но при загрузке можно производить сканирование записей и выявлять те, которые соответствуют понятию RDF-документа и накапливать их координаты в списке на загрузку. При этом, однако, секция кассеты, хранящая оригиналы файлов, может оказаться в другом месте и надо знать это место, а значит, знать записанную в регистраторе информацию. Таким образом, важным требованием к модели должно быть требование, чтобы могла производиться дозагрузка кассет.
Тем самым, мы ведем загрузку всей модели постепенно, прочитывая и активируя реестры, мы открываем путь для загрузки других кассет.
Другим вопросом, который надо решить, является вопрос загружать ли кассеты автоматически или загружать их по указанию пользователя. Поскольку роль реестра выполняют в системе «обычные» RDF-документы, при загрузке документа, могут появиться описания еще не загруженных кассет. Нужно ли их загружать автоматически или нет? Или вот пример: работает пользователь с фактографом, а тут появилась необходимость поработать с данными, имеющимися на съемном носителе. Хотелось бы подключить базу данных, присутствующую на носителе и продолжить работу в штатном режиме. При этом, база данных, размещенная на съемном носителе, оформляется как кассета, но ее описание, скорее всего имеется в уже загруженных реестрах, т.е. в загруженных кассетах.
Еще один пример и, соответственно, еще один вопрос. Как «нарезать» (логическую) кассету по физическим носителям? Если объем какой-то секции кассеты превышает объем носителя, то хочется иметь возможность распределения файлов кассеты по носителям.   
Документная база и расположение файлов в кассетах и секциях
Для работы с контентом документов, модель должна поддерживать координатную информацию о расположении этих документов. Использование концепции кассет, приводит к понятию документной базы. Документная база – это таблица, сопоставляющая кассете или секции URL директории, в которой располагается документ. В более общем случае, для доступа к документам может использоваться Web-сервис. Тогда в документной базе парой соответствия является идентификатор кассеты или секции и URL сервиса. Сервис может обслуживать несколько кассет, идеале – все. И тогда документная база будет скрыта интерфейсом сервиса. Однако, нас интересует и безсервисный вариант, поскольку не на каждой клиентской машине имеется хороший Интернет и свой менеджер сервисов.
Рассмотрим общую схему формирования URL ресурса, используя документную базу. Пусть имеется URI документа, построенный по предложенному способу:
[протокол] :// [идентификатор кассеты] @ [домен] / [код документа]
Объединяя идентификатор кассеты с доменом, мы получим полный идентификатор кассеты C, соответственно в качестве составляющих URI документа , мы имеем тройку {P, C, D}, где переменными обозначены соответствующие поля URI. К данному набору переменных, в запросе добавляется еще вид запроса Q. Например, можно запрашивать из секции preview фотографию уменьшенного размера.
Получение URL запрашиваемого документа, выполним в три этапа. Сначала сформируем логическое имя секции кассеты, к которой обращен запрос, потом по документной базе найдем URL корневой директории секции, потом на основе полученного URL, кода документа и вида запроса, построим URL документа. Рассмотрим этапы подробнее.
Этап 1.
SectionUri = MakeSU(P, C, Q)
Формат SectionUri предполагается достаточно простым – это конкатенация строк
[полный идентификатор кассеты] ! [указатель секции]
Где указатель секции вычисляется по виду запроса Q и может быть или original или preview с соответствующим расширителем.
Этап 2.
В таблице документной базы мы пытаемся найти строчку, соответствующую построенному URI секции. Если такой строчки нет, то мы обрезаем расширитель и снова ищем строку соответствия. Если и такой строки нет, то мы после восклицательного знака выставляем meta и тогда уже должны найти координату кассеты.
Здесь мы используем уже обсуждавшиеся принципы, что «главной» секцией кассеты является секция meta, метаинформация всегда должна быть доступной для модели и из модели. Секции оригиналов и предвычисленных вариантов файлов, могут быть перемещены по тем или иным соображениям. Важно лишь сохранить структуру директорий при таком перемещении. Поясним это на примере. Пусть у нас есть целостная кассета в виде дерева директорий и файлов:
<directory name=”MyCassette”>
	<directory name=”meta”>
    	<!--  RDF-документы, содержащие метаинформацию по кассете  -->
	</directory>
	<directory name=”preview”>
    	<!--  директории и файлы, содержащие предвычисленную информацию  -->
	</directory>
 
	<!--  другие директории и файлы, составляющие оригинал содержимого кассеты  -->
  
</directory>
 
Эту информацию без ущерба для логики доступа можно «разбросать» по трем директориям, расположенным в разных местах:
<directory name=”MyCassette”>
	<directory name=”meta”>
    	<!--  RDF-документы, содержащие метаинформацию по кассете  -->
	</directory>
</directory>
<directory name=”MyCassette”>
	<directory name=”preview”>
    	<!--  директории и файлы, содержащие предвычисленную информацию  -->
	</directory>
</directory>
<directory name=”MyCassette”>
 
	<!--  другие директории и файлы, составляющие оригинал содержимого кассеты  -->
  
</directory>
 
Признак «кассетности» отсутствует лишь у директории с оригиналами. В других директориях наличие поддиректорий meta и preview является таким признаком. Отсутствие обязательного признака у директории с оригиналами объясняется тем, что в кассету может быть «превращен» информационный блок, который технически (CD-DVD) или по некоторым условиям, не может быть изменен добавлением информации. Желательно все-же предусмотреть какой-то признак, например файл со специальным названием, для тех случаев, когда внесение информации находится под нашим контролем.
Этап 3.
В результате предыдущего этапа мы получили значение базы секции кассеты SectionBase. Естественно, что искомое значение URL документа вычисляется с помощью некоторой функции:
DocumentURL = MakeDocumentURL(P, SectionBase, D, Q).
 
Теперь рассмотрим процесс формирования документной базы по мере загрузки информации.
Предполагается порядок загрузки документов выдерживать от ближних файлов к удаленным. Причем тогда, когда какое-то соответствие установлено, более поздняя, а значит – более дальняя информация не переустанавливая данное соответствие.
При вводе или сканировании RDF-документа, изменения в документную базу могут вносить только записи cassette или cassetteSection. Поле cassetteLocation в записи cassette означает базу метаинформации определяемой кассеты. В cassetteSection очевидным образом вычисляется информация о виде секции, логическом URI секции и URL базы.     
  
Использование копий документов и секций вместо оригиналов
Конфигурирование моделей
Рассмотрим примеры конфигурирования пользовательских приложений.
Первый пример – одиночный пользователь, поддерживающий свою базу данных и формирующий свой архив документов. Ему достаточно одного регистратора, хранящегося в одной кассете вместе с файлами базы данных. В регистраторе, кроме того, регистрируются все формируемые кассеты с документным архивом.
Функциональность фактографа
Ввод данных в базу данных и редактирование данных
Подключение к базе данных папки или тома – создание кассеты
Перенос кассеты в архив
Подключение к общей базе данных
Перенос (части) своей базы данных в общее пользование
Перенос «случайного» документа в кассету
Работа с документами в паре фактограф-«прикладные программы Windows»
Работа с фотографиями в паре фактограф-Picasa
Генерация сайта (интерфейса) пользователя с доступом к документам и базе данных
Возвращение (на доработку) кассеты из архива
Генерация (подарочного) диска с частью базы данных и интерфейсом доступа
Совместная работа многих редактирующих операторов и пользователей
Автоматическая или ручная смена рабочего документа пользователя
 
Реализация функциональности ввода и редактирования данных осуществляется фактографом через базовый интерфейс MVE. Рассмотрим сценарии реализации остальных функций, указанных в списке.
 
Подключение к базе данных папки или тома. Сценарий такого действия достаточно прост. Сначала надо в меню найти раздел «File/Connect cassette» и кликнуть его. Кассеты могут быть зарегистрированными или незарегистрированными. Для начала, разобьем действия на независимые. Действие «подключить кассету» имеет дело с зарегистрированной кассетой и может быть выполнено дойным кликом на иконку кассеты с последующим подтверждением пользователя о том, что подключение состоялось. Второй способ – через меню, когда нажатие «подключить кассету», приводит к появлению поискового интерфейса, т.е. выполнится действие «найти кассету». Нужно ли, при этом, помещать поиск кассеты в поисковое меню – вопрос.
Другое действие – «зарегистрировать кассету». Вообще говоря, «утеря» регистрации кассеты – дело неправильное, но, для съемных носителей – практически неизбежное. Надо будет продумать стратегию работы с автономными «островками» данных.
 
Что такое – создание кассеты?  Возможны два варианта создания кассеты. Первый – создание пустой кассеты. В этом случае, кроме порождения объекта класса «кассета», в рабочей области пользователя будет сформирована директория кассеты с ее наполнением. Второй вариант – формирование кассеты на базе папки файловой системы. В этом случае, папка оригиналов файлов останется на месте, а в рабочей области, по папке-оригиналу будет порождена папка кассеты (метаинформация и предвычисления). И папка-оригинал и папка кассеты (с предвычислениями), будут зарегистрированы в базе данных за порожденной кассетой. Данная функциональность достигается через меню, в котором находится нужная директория и процесс «перепахивания» файлов директории программой SunTzu начинается. Вопрос о возможности инициировать данное действие другими способами, напр. с помощью операций Drag and Drop, оставим открытым.
 
К созданию кассеты примыкает вариант добавления «случайного» документа в кассету. При этом предполагается, что кассета существует, является активной и доступной для модификации данным агентом. Файл документа можно «перетянуть и бросить» на объект кассеты. Надо бы не забыть проверку на то, что файл имеется в данной кассете, а может, он зарегистрирован в другой кассете, что не допустимо.
 
Активную кассету можно деактивировать и перенести в архив. Для архива используется другая, чем рабочая область, директория. Более того, архивная область может (и должна) располагаться в публичном месте, а значит, запись в архив может выполняться на более высоком, в смысле интеграции, уровне. Эргономически, возможны манипуляции уровня меню, но и возможны Drag and Drop манипуляции по «перетаскиванию» кассеты из одного места в другое.
 
Для эффективной работы с кассетами понадобится визуальное сопровождение этой работы. Это означает, что кассета должна иметь различное графическое воплощение (иконку) в зависимости от того, активная она или нет. Другое измерение – архивная или нет. Видимо, достаточно постулировать, что эти изменения совпадают. То есть, активная кассета – это неархивная. А пассивная – архивная и наоборот. Над этим надо будет подумать дополнительно.
 
Следующая функциональность – подключение к общей базе данных. В принципе, подключенность к общим данным, должно быть «встроенным» свойством, нарушающимся только для автономного режима работы системы. Но одно дело использовать общие данные в своей работе и другое дело – редактировать общие данные. Для начала, пользователю должно быть позволено редактировать «чужие» данные. Наверное, не стоит порождать более сложные варианты отношений к правам редактирования общих данных.
 
Как запретить пользователю редактировать «чужие» данные. Визуально, у него нет отличия между своими и «чужими» данными. Если действительно запрещать, то это может озадачивать пользователя в том, почему изменения, которые он вносит, не фиксируются а «исчезают». Другим вариантом, более «лояльного» отношения к редактированию пользователем общих данных, является вариант, когда такое редактирование позволено всегда, но не всегда оно доходит до других пользователей.
 
 
 
Ознакомление пользователя с фактографом
Установка фактографа на компьютер пользователя
При установке фактографа на компьютер пользователя выполняется следующее:
- переносится директория deploy системы MVE
- переносится директория bin системы SunTzu
- создается реестр фактографа
- создается архив пользователя
- подготовленная кассета с тестовыми данными переносится в архив пользователя и прописывается в реестре
 
Надо ввести понятие «рабочая кассета»!
 
Демонстрационные сценарии
Ведение персональной или коллективной базы данных
Персональный фотоархив
Профессиональный архив документов
Виртуальный музей
Социальная сеть
Юбилейный CD-DVD
Специализированное рабочее место ввода-редактирования данных
Демонстрация работы с контекстами
 
 
    
Внесение изменений в MVE фактографа
Этап 1. Введение словаря баз документов
В нынешней реализации MVE уже имеется вариант такой базы – это фотобаза:
Dictionary<string, string> photobase;
В принципе – это нам и надо, но в более обобщенном виде документной базы. Тем не менее, во избежание путаницы, надо будет ввести другой словарь:
Dictionary<string, string> documentbase;
В котором первое значение – логическое имя кассеты или секции, а второе значение – URL директории, в котором кассета или секция кассеты.
 
Логическое имя устроено следующим образом:
[полный идентификатор кассеты] 
или
[полный идентификатор кассеты] ! [указатель секции]
Причем:
Второй вариант с указателем секции meta эквивалентен первому варианту
Указатель секции может быть: original | meta | preview | preview.[расширитель]
Расширитель зависит от протокола, при протоколе iiss предполагаются следующие специализированные варианты: small | medium | normal
Структура директорий, которые соответствуют специализированным секциям следующая: [базовая директория] / preview / [специализатор]
 
У базовой директории, в которой располагается кассета или ее часть, может быть произвольное имя. Однако, при возможности регулировать этот вопрос, рекомендуется называть директорию сокращенным именем кассеты.
Этап 2. Установка документной базы через конфигуратор
Это также аналогично уже имеющейся конструкции:
  <photobase name="iisstore">C:/home/arch_photos/internet_photos/</photobase>
Введем новую конструкцию:
<documentbase name=”логическое имя”>URL-директории</documentbase>
Логическое имя кассеты или секции устроено описанным ранее способом.
В URL директории могут использоваться разделителями как традиционный ‘/’, так и ‘\’ в случаях, когда это не приводит к недоразумениям. Также URL может заканчиваться разделителем или нет, это эквивалентно.
Этап 3. Загрузка кассеты
Как было указано ранее, кассета состоит из метаинформации и файлов документов. Загрузка кассеты означает загрузку в модель метаинформации и загрузку определенных файлов из документного массива. Этими определенными файлами являются RDF-файлы базы данных. Последнее означает, в частности, что надо иметь способ определения является ли файл RDF-документом базы данных. Видимо, проще всего зафиксировать этот факт в расширителе RDF-файла. Выберем для этого расширение .fog (fact-o-graph). А для content-type будем использовать text/fog.
 
Еще один существенный вопрос для предварительного обсуждения заключается в том, всю ли метаинформацию надо загружать в модель. Ясно, что часть метаинформации может иметь некоторый служебный для кассеты смысл. Возможно, надо будет «спрятать» такую информацию, напр. в поддиректорию директории meta. Пока мы будем считать, что загружаются все метаинформационные файлы из директории meta. Почему этих файлов может быть не один? Дело в том, что существенная часть метаинформации, связанная с расположением и взаимным расположением документов, не должна редактироваться (кем попало). Если у нас будет механизм указания запрета на редактирование RDF-документа, то мы сможем часть метаинформации располагать в публично редактируемом RDF-документе, а сохранную часть – в запрещенном для редактирования документе.
 
Вопросом также является то, каким образом узнать имена метаинформационных файлов. Если среда публикации кассеты не поддерживает запросов на получение списка файлов, содержащихся в директории, то надо иметь другие возможности определения этих имен. Разумно сделать имена этих файлов вычисляемыми. В текущем варианте протокола iiss, имя такого файла формируется как
[короткое имя кассеты]_current.xml
Сохраним этот подход, только заменим .xml на .fog.
 
Этап 4. Сомнения
В результате разговора с Петром, возникли сомнения и альтернативы. Попробую структурировать рассмотренные вопросы.
Первый вопрос – использование восклицательного знака для отделения имени кассеты от имени секции. Восклицательный знак не соответствует синтаксису URI. Но дело в том, что предлагаемая конструкция не является URI, а является синтетическим указателем секции, используемым в словаре документных баз.
Второй вопрос заключается в предложении ввести обязательную директорию originals в общую конструкцию кассеты. По моим рассуждениям, этого нельзя было делать, если иметь ввиду достаточно произвольный характер исходного материала, на который, часто нет возможности повлиять. Например, исходным материалом мог бы стать информационный массив, расположенный на оптическом диске. Или что-то интернетовское, нам не подвластное.
Рассматриваемый вопрос сопряжен с другим вопросом: на что указывает URL, используемый в словаре документных баз. Мое предыдущее предложение было, что URL указывает не некоторую «базовую» директорию, являющуюся как бы «осколком» от базовой директории кассеты. А в этой базовой директории имеется директория meta или preview или просто данные. Альтернативным решением является использование URL для указания на конкретную директорию, в которой расположена указываемая секция. При этом, пожелание Петра легко можно удовлетворить, поскольку такой указатель может указывать как на директорию originals, располагающуюся в кассете, так и на отдельную директорию или диск, в случае «внешнего» нахождения оригиналов контента кассеты.
Мое возражение методу прямого указания на секцию кассеты сводится к тому, что публикация кассеты может располагаться в таком месте, у которого нельзя внешним образом выявлять родительский контекст и, поэтому, переходить к «родственникам», т.е. к другим секциям. К этому возражению можно сделать возражение, что все секции разобранной кассеты должны быть описаны в базе данных, а поэтому, не требуется для выявления координаты секции, использовать координату «чужой» секции.
Следующий дискуссионный вопрос заключается в предложении Петра упростить структуру хранилища кассет. По моему (пока не описанному) замыслу, было следующее:
В соответствии с решениями SunTzu, есть директория iissincomming, содержащая оригиналы контента, предназначенного для оформления в виде кассет и iiss, предназначенная для хранения кассетной метаинформации и дополнительной информации. SunTzu производит обработку оригиналов кассет и синхронизирует оригиналы с вычисленной информацией. По моему предположению, кассеты, которые уже собраны и готовы к передаче в архив, изымаются из этих двух директорий и помещаются в специальное хранилище. Петр предложил использовать для хранилища директорию iiss. Для этого и нужна структура кассеты, содержащая раздел originals. Хотя для перемещения в iiss-кассету не обязательно иметь отдельную директорию, но так будет удобнее.  Другое предложение Петра – хранить оригиналы документов в виде файлов с регулярной системой имен, например используя какую-то нумерацию или кодирование. Еще одно предложение – компрессовать документы прямо в директории оригиналов, поскольку информация при этом не теряется. Последнее еще надо проанализировать, но в целом, предложения выглядят разумными.
Таким образом, набор директорий, содержащийся в iissincomming обрабатываются с помощью SunTzu и постепенно выводятся оттуда, размещаясь в основном хранилище, расположенном в iiss. Естественно, должен иметься и обратный процесс – помещение новых директорий в iissincomming.
Имеется одно важное замечание к данной схеме: iissincomming может быть перечислением директорий, предназначенных для архивации. А сами директории, при этом могут располагаться на своих местах или быть съемными дисками.
Вернемся к содержательным этапам модернизации системы средствами поддержки работы с кассетами.
Этап 5. Доступ к документам
Исходной информацией для доступа к документам является URI документа.
 
        
 
Приложения
Соображения по поводу математических основ работы
Хорошая математика может быть при анализе вопросов работы с распределенными документами.
Формализация 1
- множество документов, содержащее множество записей и операторов substitute, delete.
- формализация асинхронных действий с моделью
- анализ цепочек (деревьев) переименований (потеря синхронизации данных)
-
Соображения по поводу программы Fact-o-graph
Применение текущей версии (MVE + SunTzu)
 
Программа должна очень быстро и достаточно просто ставиться на пользовательский компьютер. Что этому мешает? Во-первых, нет инсталлятора. Во-вторых, есть желание сохранять сложные конфигурации для решения сложных задач или нестандартностью компьютера пользователя.
Идеальное решение. Инсталлировал программу, запустил. Все уже готово к работе. В частности, имеется, желательно скрытая, область для хранения рабочих кассет. Пользователь может иметь следующие основные сценарии работы:
- ввод и редактирование базы данных;
- размещение в системе блоков архивных данных;
-
 
Развитие технологии и интерфейсов
 
Примеры кассет и конфигураторов
 
 

