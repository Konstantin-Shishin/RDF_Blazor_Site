Описание документного хранилища (DocumentStorage)
=================================================

Основным классом, реализующим документное хранилище является DStorage. Класс имеет конструктор, 
который ничего не делает. Главный инициализатор хранилища - метод Init, параметром к которому
подается конфигуратор хранилища в XML-формате. Пример конфигуратора:

<config>
  <database dbname='polar20150825' connectionstring='polar:D:\home\FactographDatabases\polartest\'/>
  <LoadCassette regime='nodata'>D:\Home\FactographProjects\SampleOfCassette</LoadCassette>
  <!--LoadCassette write='yes'>D:\home\FactographProjects\Test20130213</LoadCassette-->
</config> 

В конфигураторе элементами LoadCassette указываются кассеты, которые объединяют свой контент в рамках хранилища.
Также может указываться база данных (см. позже).

Указание кассеты в конфигураторе, делает после инициализации хранилища кассету "активной". Это означает,
что документы кассеты становятся доступными для получения в том или ином виде. Кроме того, могут изменяться
файлы базы данных. Причем если кассета определена как regime='nodata', изменения в файлах кассеты не 
допускаются. Если кассета помечена, как write='yes', то некоторые фог-файлы могут быть изменены. Критерии
и порядок изменения, будут уточнены позже.

Инициирование (пока) без добавлений, повторное инициирование формирует новую конфигурацию активных кассет. 
Каждая кассета имеет (должна иметь) уникальное имя (идентификатор). Это имя является основой для именования
хранимых файлов. То есть, для каждого хранимого документного файла есть т.н. URI, построенный по определенным 
правилам. Пример подобного URI:
iiss://SampleOfCassette@iis.nsk.su/0001/0001/0002
Имена URI, как и кассет, регистро-независимы. Это надо иметь ввиду при назначении уникальных имен для кассет.

Хранилище может быть с базой данных или без.

Главный набор методов в обоих режимах - получение доступа к хранимым файлам документов. По URI можно найти 
путь к файлам-оригиналам и, для мультимедиа - к файлам-копиям. Для фотографий, есть три интернетовских
типоразмера: s - small, m - medium, n - normal. Для видео - только medium, который не указывается параметром,
для аудио - только оригинал (???).

Процедуры получения path для документов не выдают расширения названия файлов. Для оригиналов расширение надо 
запрошивать или получать из метаинформации, для интернетовских могут быть варианты. Напр. для видео альтернативами 
могут быть .mp4 и .flv. 

((((((((((((((     Есть еще DeepZoom          )))))))))))))))

((((( Раздел логов написан невнятно, но как есть... )))))

Хранилище с базой данных
========================

База данных "прикрепляется" к хранилищу через переменную
private DbAdapter dbadapter = null;
имеющую интерфейс DbAdapter
и метод 
        public void InitAdapter(DbAdapter adapter) 
        { 
            dbadapter = adapter;
            if (adapter != null) dbadapter.Init(connectionstring);
        }
все понятно...

База данных может быть "загружена" ("перезагружена") и может быть использована для доступа к данным.
База данных загружается из имеющихся в кассетах хранилища fog-файлов. При (пере) загрузке данных,
сначала база данных сбрасывается, потом последовательно читается из fog-файлов, потом выполняются 
заключительные операции, напр. построение индексов. 

В процессе формирования базы данных могут производиться некоторые специальные действия. К ним относятся:
- коррекция идентификаторов сущностей, сейчас это задается тождественным преобразованием 
private static Func<string, string> ConvertId = id => id;
- коррекция элементов фог-файлов
public static Func<XElement, XElement> ConvertXElement = xel => ...

Пока перекодирование делается из fog-формата, производимого в CManager'е.

Третья коррекция - нахождение имен-оригиналов. Логика в этом вопросе следующая. Идентификатор,
использующийся в позиции rdf:about или rdf:resource, может быть эквивалентен другим идентификаторам.
Для удобства обработки, вся цепочка эквивалентности заменяется одним идентификатором, который
называется оригиналом. Другой составляющей цепочек эквивалентности является выделение определяющей
(оригинальной) записи. Это означает, что для идентификаторов, входящих в цепочку эквивалентности
могут существовать разные определения (rdf:about = ...). Мы выбираем определения, соответствующие
идентификатору-оригиналу, а среди них единственное определение у которого отметка времени mT является
максимальной. Цепочка эквивалентных имен порождается отношениями <substitute old-id='id1' new-id='id2'/>.
Оригиналом является идентификатор, который не стоит в позиции old-id. Цепочка, может иметь разветвления,
но не должно быть нескольких оригиналов. В практическом плане, в случае наличия нескольких оригиналов,
выбирается любой, но единственный. 

Другим "сложным" оператором является оператор уничтожения сущности <delete id='id'/>. Этот оператор
"уничтожает" все определения цепочки эквивалентности, включая и определение оригинала. Это "плохой"
оператор по двум причинам. Во-первых, использование идентификаторов цепочки "автоматически" не 
исчезает, во-вторых, нет механизма "восстановить" определение для уничтоженной цепочки. 

Итак, рассмотрим семантику динамических изменений в данных: появление нового, редактирование имеющегося,
уничтожение имеющегося элементов данных. Эти изменения выполняются потоком команд, среди которых есть команды
добавления/редактирования в виде записей, снабженных некоторыми дополнительными атрибутами. Также есть
команды уничтожения delete и есть команды установления эквивалентности substitute.  

Заметим, что есть текущий набор fog-документов, на основе которого строится база данных. Поэтому база данных
сначала формируется и fog-документы не изменяются, а потом появляется поток команд изменяющий как fog-документы,
так и базу данных. Отличие редактирующего потока в следующем:
- в команде всегда имеется идентификатор юзера/владельца, идентификатор проверяется и используется для нахождения 
подходящего для записи fog-документа этого юзера;
- не всегда имеется идентификатор новой записи, в этом случае, идентификатор берется из активного fog-документа 
юзера.

Здесь есть принципиальный момент. Команды загрузки базы данных относятся к адаптеру базы данных, а команды 
редактирования относятся к хранилищу данных/документов. 

Для хранилища попробуем обойтись одним методом редактирования. 
public XElement EditCommand(XElement comm);
Идея заключается в том, что это либо команда delete, либо команда substitute, либо запись. В последнем случае
элемент может не иметь идентификатора rdf:about. При этом комманда имеет дополнительные отрибуты 
owner='код пользователя' и mT='отметка времени'. Что это означает в смысле редактирования набора fog-документов?
По коду пользователя определяется активный fog-документ. Если идентификатора записи нет, то берется новый 
идентификатор из fog-документа пользователя. 

Некоторая логика сопровождает случай, когда элемент с таким идентификатором уже существует (в наборе fog-документов
и базе данных). Если отметка времени более ранняя, чем зафиксированная в базе данных для этого индентификатора, то 
изменения в данных не производятся. Если отметка времени самая поздняя, есть активный fog-документ пользователя
Если по заданному идентификатору имеется предыдущий оригинал, то от может участвовать в формировании нового через 
значения полей, которые присутствуют в "старой" записи и отсутствуют в "новой". Хотя этот тезис спорный...

Я все пока не ушел от таблицы эквивалентностей. Вот теперь надо реализовывать для хранилища команды редактирования,
и снова таблица эквивалентностей нужна. Для delete они не нужна, можно просто проставить delete на этот идентификатор
и уничтожить запись в базе данных. Есть правда нюанс: delete может указывать на другой идентификатор цепочки 
эквивалентностей. А для применения substitute в динамике обработки, уже таблица нужна обязательно. В принципе, 
таблица очень большая - по входу на каждый идентификатор. Ее хранить в оперативной памяти может оказаться накладным. 
Для ее уменьшения надо большую часть идентификаторов вывести из под действия таблицы. Это можно сделать если есть 
некоторые "правильные" идентификаторы, по которым дополнительных действия по установлению эквивалентности делать не
требуется. Тогда эти "правильные" идентификаторы будут храниться просто в основной части базы данных. Тогда появление 
идентификтора приводит к проверкам: сначала в table_ri, потом поиск определения в базе данных. Если не найдено, то это 
отсутствующий, если найдено в основной части, это "нормальный" идентификатор. Если найден в первой части - это 
идентификатор из цепочки. Такой подход требует, чтобы количество цепочек не увеличивалось сеанс от сеанса. То есть, 
надо иметь способ превращения цепочки в "нормальный" идентификатор. В чем проблема? Проблемы не видно для одинаковых 
идентификаторов с временной разметкой. Нам надо только зафиксировать время фиксации базы данных и следить за тем,
что новые временные отметки имеют более позднее происхождение. Аналогично для substitue. Надо, чтобы идентификаторы,
не являющиеся оригиналами, не появлялись в редактируемых данных. Соответственно в операторе substitute, как-то это
также должно проявлятся. 

В общем, возможны два подхода. Один дорогой - поддерживать таблицу эквивалентностей и отрабатывать с ее помощью все
команды. Второй - считать, что цепочки эквивалентностей уже "спрятаны" и "те" идентификаторы уже не должны появлятся
в данных. Тогда можно начинать новую таблицу эквивалентностей и использовать ее. Второй подход выглядит более экономным.
К чему может приводить "забвение" старых идентификаторов из цепочек эквивалентностей? Если это будут использования,
то просто до следующей перезагрузки будут висящие ссылки. Если есть определения, то они будут "вычищены" следующей 
пререзагрузкой. 

Минимизация второго варианта приводит такой схеме. Все временные отметки в динамике игнорируются, поскольку предполагается,
что каждая следующая, позже предыдущих. Оператор delete нормально отрабатывается. Оператор substitute только записывается 
в fog-документ, но не отрабатывается базой данных. 

20150923 08:33
Вышел на сложности, связанные с синхронной записью изменений в данных. Запись в фог-файл и запись в базу данных. В принципе,
они близкие. Но есть существенные отличия. Входом является оператор - XML-запись, которая может быть элементом или командой
уничтожения или замены. Элемент может иметь или не иметь идентификатор. Если идентификатора нет, то это (обязательно!) новый
элемент. Его идентификатор определяется обращением к хранилищу. Если идентификатор есть, то это (почти всегда?) существующий
элемент, которому дается новое значение. Новое значение может быть (очень) частичным, т.е. определять некоторые свойства,
а другие не определять. Другие берутся из "старого". Это приближает редактирование к существующей семантике RDF-Sparql.
Действительно, для добавления, в Sparle просто добавляется свойство, отсутствующее в базе данных. Если надо заменить свойство, 
то в традиционной семантике надо сначала его уничтожить, а потом создать снова.   
  